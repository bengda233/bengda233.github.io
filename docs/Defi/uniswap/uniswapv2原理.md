# UniswapV2 原理
Uniswap V2是Uniswap V1的升级版本，基于v1同样的公式实现，建议大家先去看我写的V1，因为V1和V2核心思想都是**恒定乘积公式**，相比Uniswap V1主要有如下新特性：

### 1.支持ERC20代币/ERC20代币交易对
V2不用再向v1那样，需要先使用TokenA来换取ETH，之后再通过ETH来换取TokenB。  
**好处**：  
（1）此改动减少了流动性提供者的成本，因为有ETH作为过渡代币总是会比两个token直接相关的损失大（如果ETH价格波动）。  
（2）减少了交易者的成本,因为有ETH作为过渡代币时交易者必须支付的费用是直接购买ABC/XYZ对的费用的两倍，并且遭受两次滑点。  
**问题**：  
当ERC20交易对数量激增时，找到指定货币对的最佳路径就会困难很多，于是V2引入了路由。

### 2.价格预言
uniswap v2通过测算和记录每个区块第一笔交易之前的价格（也就是前一个区块最后的价格）。  
具体算法：追踪每个和合约交互的区块的开始处的价格累加和，每个价格用距离上一个更新价格的区块的时间进行加权，意思是：累加器的值在任意时间的值等于合约历史上每秒现货价格的和。  

![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/af011811f7e340d9afa9a786ea9f8495~tplv-k3u1fbpfcp-watermark.image?)

计算加权平均价，外部调用者拿到T1和T2时间累加器的值，用（后值-前值）/经过的时间。
用户可以选择起始和结束时间。

uniswap会同时追踪A/B和B/A的价格，因为采取均值的方式他们两就不是倒数的关系了。

核心合约在每次交互后缓存它的资金储备，用缓存的资金储备更新价格预言而不用当前资金储备。（预防有人发送资产给交易对合约，用来改变它的余额和边际价格，但又不和它交互）

**好处：**  
大大减少价格受到操控的风险。  

v1作为链上价格预言是不安全的，因为它非常容易被操纵。在一个block的开头大量卖出某种资产A从而影响价格，在该block的中间根据这个大幅波动的价格进行其它合约的其它操作(非uniswap交易对合约)，在该block的最后再买入相同数量的资产A使价格回到正常水平。  

V2如果攻击者提交了一笔交易（transaction）尝试在区块末尾处操纵价格，其他的套利者可以提交另一个交易（transaction）立即进行反向交易。除非他们可以挖出下一个区块，否则他们他们没有特殊的的套利优势。  

### 3.价格计算精度
uniswap v2用简单的二进制定点数格式编码和控制价格。价格存储为UQ112.112格式，意思是在小数点的任意一边都有112位精度，无符号。
储备资金各自存在uint112中，剩余32位存储空间用于描述累加过程，保存当前区块的创建时间

**问题：**  
unit时间戳会在2106年7月2日溢出  
解决方法是在每个间隔至少检查一次价格（大约136年一次）

## 4.Flash Swaps
相当于闪电贷，V2允许先接收和使用资产再支付，只需要他们在一个原子操作里。swap函数里可以调用户指定的回调合约，转出用户请求的代币并保持不变，回调完成后合约检查新余额，是否不变。（会收取0.3%的手续费）

**问题：**  
可能会出现空手套利，只要两个交易所有价格差。  
比如有uniswap v2和其他的DEX，都是A/B代币对。
先在uniswap这借A，换B。然后再拿B去DEX里换A0，再把A0还回来。A0-A就是我们得到的利。

## 5.协议手续费
v2可以选择是否打开0.05%的协议手续费，如果打开，手续费会被发送给工厂合约中指定的feeTo地址。将0.3%的交易手续里的1/6发送给feeto.这个费用只有在增加/减小流动性时才会做相应计算。

具体计算：  


![IMG_9472.JPG](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9a011c16ac91408aafc9405ae58eb46d~tplv-k3u1fbpfcp-watermark.image?)

## 6.资金池份额的元交易
用户可以签名授权他们资金池份额转账，而不用他们的地址进行链上的转账。也就是说其他人可以拿到授权后直接用用户的名义签名交易、转账执行其他操作。

## 7.手续费调整
uniswap v1里面合约强制确保：`(x1-0.003X-in)*y1=X0*Y0`

V2的flash中，可能存在用户token1和token2各还一点，保证还回同样的资产。所以此时的x-in和y-in可能都不为0，那么就需要换一套计算方式：
`(x1-0.003X-in)*(y1-0.003Y-in)=X0*Y0`

## 8.救援函数sync()和skim()
sync()用来同步合约中缓存的资产数量（储备金）为当前值，目的是处理合约目前汇率不合理并且没有流动性提供者的情况，一种优雅的恢复机制。  
skim()是发送到代币的数量溢出了uint112大小的储备金存储空间时的恢复机制，它允许用户提出合约资产值和uint112最大值之间的差值。

## **9.处理非标准和非常规代币**
v1会将不标准函数的返回值直接设为false,并回滚。导致泰达币和币安币无法使用（因为他们的transfer和transferfrom没有返回值，而ERC20的标准是实现的）

v2将没有返回值的视为成功

## 10.初始化流动性供给
Uniswap v2初始铸造份额等于存入代币数量的几何平均值：

![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a8ccdd7f48cc4f3c9e79f00eff08a189~tplv-k3u1fbpfcp-watermark.image?)

公式确保了流动性资金池份额的价值在任意时间和在本质上和初始存入的比例无关。

**好处：**  
规避v1中第一个存入代币得到的流动性值与初始化ETH的值相等，导致过分依赖初始化流动性比例

**问题：**  
流动性资金池份额的价值随时间增长是可能的，比如：通过累加交易手续费或者向流动性资金池“捐款”。为了解决这个问题，Uniswap v2销毁第一次铸造的1e-15资金池份额，发送到全零地址而不是铸造者。

虽然对交易微不足道但是会大大提升攻击成本，比如想要提高流动性资金池份额价值到100美元，攻击者需要捐献100000美元到资金池总。

## 11.WETH
ETH的转账接口和ERC20交互用的标准接口不同，因为Uniswap v2支持任意ERC20交易对，它现在不再支持无包装的ETH。如果添加这个特性需要两倍的核心代码，并且产生ETH和WETH流动性分散的风险。原生ETH需要包装后才能在Uniswap v2上交易。

所以Uniswap V2中不支持ETH，用户在使用交易对前必须先换成WETH，实际上Uniswap V2内部自动把用户提供的ETH转化成WETH了。

## 12. **确定交易对地址**
v1是create构造代币地址的，v2用create2构造交易对地址

## 13.**最大代币余额**
就是之前说的，代币的总额最大只能为2^112-1，如果超过了这个值，交易会报错。此时任何人可以调用skim()函数就行恢复。
